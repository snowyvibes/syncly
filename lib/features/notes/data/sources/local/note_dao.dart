// lib/features/notes/data/sources/local/note_dao.dart
import 'package:drift/drift.dart';
import 'package:syncly/database/local/drift_database.dart';
import 'package:syncly/features/notes/data/models/note_table.dart';

part 'note_dao.g.dart'; // Generated by build_runner

@DriftAccessor(tables: [NoteTable])
class NotesDao extends DatabaseAccessor<AppDatabase> with _$NotesDaoMixin {
  NotesDao(super.db);

  Future<List<NoteTableData>> getAllNotes() => select(noteTable).get();

  Future<List<NoteTableData>> getNotesByFolder(String folderName) =>
      (select(noteTable)..where((note) => note.folder.equals(folderName))).get();

  Future<List<NoteTableData>> getNotesWithoutFolder() =>
      (select(noteTable)..where((note) => note.folder.isNull())).get();

  Future<NoteTableData?> getNoteById(String id) =>
      (select(noteTable)..where((note) => note.id.equals(id))).getSingleOrNull();

  Future<int> insertNote(Insertable<NoteTableData> note) => into(noteTable).insert(note);

  Future<bool> updateNote(Insertable<NoteTableData> note) => update(noteTable).replace(note);

  Future<int> deleteNote(String id) =>
      (delete(noteTable)..where((note) => note.id.equals(id))).go();

  Future<int> deleteNotesByFolder(String folderName) =>
      (delete(noteTable)..where((note) => note.folder.equals(folderName))).go();

  Future<List<String>> getAllFolders() async {
    final query = selectOnly(noteTable, distinct: true)
      ..addColumns([noteTable.folder])
      ..where(noteTable.folder.isNotNull());

    final results = await query.get();
    return results.map((row) => row.read(noteTable.folder)!).toList();
  }

  Future<List<NoteTableData>> searchNotes(String searchTerm) {
    final lowerSearchTerm = searchTerm.toLowerCase();
    return (select(noteTable)
          ..where(
            (note) =>
                note.title.lower().contains(lowerSearchTerm) |
                note.content.lower().contains(lowerSearchTerm),
          )
          ..orderBy([(note) => OrderingTerm.desc(note.lastUpdated)]))
        .get();
  }

  Future<List<NoteTableData>> getNotesOrderedByLastUpdated() =>
      (select(noteTable)..orderBy([(note) => OrderingTerm.desc(note.lastUpdated)])).get();

  Future<List<NoteTableData>> getNotesOrderedByCreated() =>
      (select(noteTable)..orderBy([(note) => OrderingTerm.desc(note.createdAt)])).get();

  Future<int> countNotesInFolder(String folderName) async {
    final query = selectOnly(noteTable)
      ..addColumns([noteTable.id.count()])
      ..where(noteTable.folder.equals(folderName));

    final result = await query.getSingle();
    return result.read(noteTable.id.count()) ?? 0;
  }

  Future<List<NoteTableData>> getRecentNotes() {
    final weekAgo = DateTime.now().subtract(const Duration(days: 7));
    return (select(noteTable)
          ..where((note) => note.lastUpdated.isBiggerThanValue(weekAgo))
          ..orderBy([(note) => OrderingTerm.desc(note.lastUpdated)]))
        .get();
  }
}
